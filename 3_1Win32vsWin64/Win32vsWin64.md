## 3장 64비트 기반 프로그래밍

<br>

### 64비트와 32비트의 구분 방법

무엇이 n비트를 결정하는가?
2가지 요소에 의해 결정된다.
1. 한번에 송수신 가능한 데이터 크기 이것은 IO버스에 의존적이다.
2. 데이터 처리 능력 즉, Cpu가 한번에 읽어 들일수 있는 명령어의 크기
>만약 송수신 가능 크기와 읽어 들일수 있는 크기가 서로 다르다면? 그것은 완벽한 n비트의 시스템이 아니다.
대부분의 경우 이 2가지 요소의 크기가 같아야 n비트 시스템이라고 한다.

<br>

### 32비트와 64비트의 차이?

1. 프로그램으로 표현할 수 있는 범위가 증가
2. **표현할 수 있는 메모리의 전체 크기**
3. 일반적으로 32bit 시스템에서 포인터의 크기는 32bit다. 마찬가지로 64bit 시스템에서 포인터의 크기는 64bit이다. 왜 그럴까?
<br>

	포인터의 값이 크다는 것은 우리가 접근가능한 주소의 폭이 넓다는 것이다. 
	따라서 포인터의 크기는 크면클수록 좋다. 하지만 버스에서 한번에 전송가능한 크기만큼을 두는것이 좋다.
	(버스에서 전송가능한 크기보다 포인터의 크기가 크게되면 성능저하게 일어나기 때문!)

<br>

	우리가 사용할수 있는 메모리 공간이 1GB라 가정해보자.
	메모리 전체를 어드레싱 하기위해서 포인터의 값은 충분히 커야 한다.
	32bit 시스템에서 어드레싱을 할수있는 범위는 2^32 즉 4GB이다.
	64bit 시스템에서 어드레싱을 할수있는 범위는 2^64로 어마어마하게 커진다.
	사용할수 있는 메모리의 크기(범위)가 극히 향상되는 것이다.

> cf) 만약 64bit 시스템 컴퓨터에서 256M의 메인메모리를 사용한다면 64bit시스템의 의미가 사라지는것이다?
아니다 가상 메모리 (Virtual memorie)로 극복할 수 있다!.

<br>

### 활용 가능 메모리 확장의 의미(코드로)

	int _tmain(void)
	{
		TCHAR str[100];			//50byte시스템일때 100byte의 메모리를 할당할 수 있는가? 불가능하다.
		_tscanf(T("%s"),str);		//만약 100byte시스템이라 한다면 그냥 쓸수 있다는 것이다.
		_tprintf(T("%s"),str);
		return 0;
	}

<br>

대안

	int _tmain(void)
	{
		TCHAR ch;
		do
		{
			_tscanf(T("%c"),str);	// 비록 100byte의 메모리를 할당할 수는없지만 이런식의 대책이 있을수 있다.
			_tprintf(T("%c"),str);	// 이영역에서 필요한 메모리는 1byte에 불과하다
		}while(ch!='\n');

		return 0;
	}
